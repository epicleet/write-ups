The task
===
I invented Anti-Fermat Key Generation for RSA cipher since I'm scared of the Fermat's Factorization Method.

Files:
- [Script](https://github.com/epicleet/write-ups/blob/master/2022/zer0ptsCTF/crypto/anti_fermat/task.py)
- [Output](https://github.com/epicleet/write-ups/blob/master/2022/zer0ptsCTF/crypto/anti_fermat/output.txt)

Task analysis
===

The challenge gave the script used to generate the output (`task.py`):

```python
from Crypto.Util.number import isPrime, getStrongPrime
from gmpy import next_prime
from secret import flag

# Anti-Fermat Key Generation
p = getStrongPrime(1024)
q = next_prime(p ^ ((1<<1024)-1))
n = p * q
e = 65537

# Encryption
m = int.from_bytes(flag, 'big')
assert m < n
c = pow(m, e, n)

print('n = {}'.format(hex(n)))
print('c = {}'.format(hex(c)))
```

And the output file generated by this script (`output.txt`):

```text
n = 0x1ffc7dc6b9667b0dcd00d6ae92fb34ed0f3d84285364c73fbf6a572c9081931be0b0610464152de7e0468ca7452c738611656f1f9217a944e64ca2b3a89d889ffc06e6503cfec3ccb491e9b6176ec468687bf4763c6591f89e750bf1e4f9d6855752c19de4289d1a7cea33b077bdcda3c84f6f3762dc9d96d2853f94cc688b3c9d8e67386a147524a2b23b1092f0be1aa286f2aa13aafba62604435acbaa79f4e53dea93ae8a22655287f4d2fa95269877991c57da6fdeeb3d46270cd69b6bfa537bfd14c926cf39b94d0f06228313d21ec6be2311f526e6515069dbb1b06fe3cf1f62c0962da2bc98fa4808c201e4efe7a252f9f823e710d6ad2fb974949751
c = 0x60160bfed79384048d0d46b807322e65c037fa90fac9fd08b512a3931b6dca2a745443a9b90de2fa47aaf8a250287e34563e6b1a6761dc0ccb99cb9d67ae1c9f49699651eafb71a74b097fc0def77cf287010f1e7bd614dccfb411cdccbb84c60830e515c05481769bd95e656d839337d430db66abcd3a869c6348616b78d06eb903f8abd121c851696bd4cb2a1a40a07eea17c4e33c6a1beafb79d881d595472ab6ce3c61d6d62c4ef6fa8903149435c844a3fab9286d212da72b2548f087e37105f4657d5a946afd12b1822ceb99c3b407bb40e21163c1466d116d67c16a2a3a79e5cc9d1f6a1054d6be6731e3cd19abbd9e9b23309f87bfe51a822410a62
```

Note that the primes `p` and `q` are generated, respectively, as a 1024-bit random prime and the next prime after the number obtained by flipping all 1024 bits of `p`, that is:

```text
p + q0 == (1<<1024)-1
q0 == ((1<<1024)-1) - p
```
where `q0` is the number from which the prime `q` will be found, that is:

```text
q == q0 + k == ((1<<1024)-1) - p + k
```

It is known that `k` is too small since the probability of finding a prime is not greater than `N` is `1/ln(N)` as shown in [Wikipedia - Prime Number Theorem](https://en.wikipedia.org/wiki/Prime_number_theorem), so we can search for it linearly. The public key can be written as:

```text
n == p*q == p*(((1<<1024)-1) - p + k)
```

Solving the challenge
===

Note that the task name is "Anti-Fermat", so in some way it must be related to Fermat. Also note that the public key can be rewritten as:

```text
n == [((1<<1024)-1 + k)/2 - ((1<<1024)-1 + k)/2 + p]*[((1<<1024)-1 + k)/2 + ((1<<1024)-1 + k)/2 - p]
n == [a - (((1<<1024)-1 + k)/2 - p)]*[a + (((1<<1024)-1 + k)/2 - p)]
n == (a - b)*(a + b) == a**2 - b**2
```
where `a == ((1<<1024)-1 + k)/2` and `b == (((1<<1024)-1 + k)/2 - p)` with `k` unknown but small. 

Using an algorithm very similar to that of Fermat's Factorization Method, we can factorize `n`:

```python
from math import isqrt

def FermatFactors(n):
    a = (((1 << 1024)-1) + 1)//2

    while True:
        b1 = a * a - n
        b = isqrt(b1)
        if b * b == b1:
            break
        a += 1
    return a-b, a + b
```

So adding the RSA decrypt, we have the full solver:

```python
from math import isqrt
from Crypto.Util.number import inverse, long_to_bytes

n = 0x1ffc7dc6b9667b0dcd00d6ae92fb34ed0f3d84285364c73fbf6a572c9081931be0b0610464152de7e0468ca7452c738611656f1f9217a944e64ca2b3a89d889ffc06e6503cfec3ccb491e9b6176ec468687bf4763c6591f89e750bf1e4f9d6855752c19de4289d1a7cea33b077bdcda3c84f6f3762dc9d96d2853f94cc688b3c9d8e67386a147524a2b23b1092f0be1aa286f2aa13aafba62604435acbaa79f4e53dea93ae8a22655287f4d2fa95269877991c57da6fdeeb3d46270cd69b6bfa537bfd14c926cf39b94d0f06228313d21ec6be2311f526e6515069dbb1b06fe3cf1f62c0962da2bc98fa4808c201e4efe7a252f9f823e710d6ad2fb974949751
c = 0x60160bfed79384048d0d46b807322e65c037fa90fac9fd08b512a3931b6dca2a745443a9b90de2fa47aaf8a250287e34563e6b1a6761dc0ccb99cb9d67ae1c9f49699651eafb71a74b097fc0def77cf287010f1e7bd614dccfb411cdccbb84c60830e515c05481769bd95e656d839337d430db66abcd3a869c6348616b78d06eb903f8abd121c851696bd4cb2a1a40a07eea17c4e33c6a1beafb79d881d595472ab6ce3c61d6d62c4ef6fa8903149435c844a3fab9286d212da72b2548f087e37105f4657d5a946afd12b1822ceb99c3b407bb40e21163c1466d116d67c16a2a3a79e5cc9d1f6a1054d6be6731e3cd19abbd9e9b23309f87bfe51a822410a62
e = 65537

def FermatFactors(n):
    a = (((1 << 1024)-1) + 1)//2

    while True:
        b1 = a * a - n
        b = isqrt(b1)
        if b * b == b1:
            break
        a += 1
    return a-b, a + b

p, q = FermatFactors(n)
assert p*q == n
phi = (p-1)*(q-1)
d = inverse(e, phi)
print(long_to_bytes(pow(c, d, n)).decode())
```

Which outputs the flag:

```text
Good job! Here is the flag:
+-----------------------------------------------------------+
| zer0pts{F3rm4t,y0ur_m3th0d_n0_l0ng3r_w0rks.y0u_4r3_f1r3d} |
+-----------------------------------------------------------+
```
